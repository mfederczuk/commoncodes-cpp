#!/bin/bash
# Bash script for unit testing.
# Copyright (C) 2020 Michael Federczuk
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

if [[ "$-" == *i* ]]; then
	\echo "${BASH_SOURCE[0]}: script was called interactively" >&2
	\return 124
fi

readonly PROGRAM="utest-script"
readonly VERSION_MAJOR=$((1)) VERSION_MINOR=$((1)) VERSION_PATCH=$((0))
readonly COPYRIGHT_YEARS=('2019' '2020') COPYRIGHT_HOLDER='Michael Federczuk'
readonly LICENSE='GPLv3+' LICENSE_DESC='GNU GPL version 3 or later' \
         LICENSE_URL='https://gnu.org/licenses/gpl.html'
readonly AUTHORS=('Michael Federczuk')
readonly REPO_URL='https://github.com/mfederczuk/utest-script'

readonly VERSION="$VERSION_MAJOR.$VERSION_MINOR.$VERSION_PATCH"
readonly COPYRIGHT_YEAR_LATEST="${COPYRIGHT_YEARS[${#COPYRIGHT_YEARS[@]} - 1]}"
declare AUTHORS_LIST="${AUTHORS[0]}"
for (( i = 1, s = ${#AUTHORS[@]} - 1; i < s; ++i )); do
	AUTHORS_LIST+=", ${AUTHORS[i]}"
done
unset -v i s
if (( ${#AUTHORS[@]} > 1 )); then
	AUTHORS_LIST+=" and ${AUTHORS[-1]}"
fi
readonly AUTHORS_LIST

readonly USAGE="\
usage: $0 [-m<cmd> [-A<arg>...]] ([-s] <file>)...
   or: $0 [-m<cmd> [-A<arg>...]] --silent-all <file>..."

readonly HELP="\
$USAGE
    Add every FILE as a test.

    Every test is executed and exit code, stdout and stderr output is saved and
    displayed in a listed format.

    Options:
      -s, --silent=<file>      add FILE as test but don't save the output of it
          --silent-all         don't save the output of any test
      -m, --command=<cmd>      pass files separately to CMD instead of executing
                                them
      -A, --command-arg=<arg>  pass ARG to CMD before the file.
                                this option can be used multiple times
          --valgrind           use 'valgrind' as CMD
      -c, --color=<when>       when to color the output (default: auto).
                                WHEN must be: 'always', 'auto', or 'never'
      -h, --help               show this summary and exit
      -V, --version            show version and legal information and exit

    Exit Status:
      (using CommonCodes v2 <https://mfederczuk.github.io/commoncodes/v2.html>)
      0   all tests passed
      32  some tests failed
      33  all tests failed

Report bugs at: <$REPO_URL>"

readonly VERSION_INFO="\
$PROGRAM $VERSION
Copyright (c) $COPYRIGHT_YEAR_LATEST $COPYRIGHT_HOLDER
License $LICENSE: $LICENSE_DESC <$LICENSE_URL>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by $AUTHORS_LIST."


check_color_support() {
	case "$TERM" in
		xterm-color|*-256color) echo true ;;
		*) echo false ;;
	esac
}

# shellcheck disable=2155
declare tests=() \
        color=$(check_color_support) \
        silent_all=false \
        command='' \
        command_args=()

option_silent() {
	if (($# < 2)); then
		echo "$0: $1: missing argument: <file>" >&2
		echo "$USAGE"
		exit 3
	fi

	tests+=("s$2")
}

option_silent_all() {
	if (($# > 1)); then
		echo "$0: $1: too many arguments: 1" >&2
		echo "$USAGE"
		exit 4
	fi

	silent_all=true
}

option_command() {
	if (($# < 2)); then
		echo "$0: $1: missing argument: <cmd>" >&2
		echo "$USAGE"
		exit 3
	fi

	command="$2"
}

option_command_arg() {
	if (($# < 2)); then
		echo "$0: $1: missing argument: <arg>" >&2
		echo "$USAGE"
		exit 3
	fi

	command_args+=("$2")
}

option_valgrind() {
	if (($# > 1)); then
		echo "$0: $1: too many arguments: 1" >&2
		exit 4
	fi

	command='valgrind'
	command_args=(
		'--leak-check=full'
		'--show-leak-kinds=all'
		'--track-origins=yes'
		'--error-exitcode=47'
	)
}

option_color() {
	if (($# < 2)); then
		echo "$0: $1: missing argument: <when>" >&2
		exit 3
	fi

	case "$opt_arg" in
		'always')
			color=true
			;;
		'auto')
			# checking if the terminal supports color
			color=$(check_color_support)
			;;
		'never')
			color=false
			;;
		*)
			echo "$0: $1: $opt_arg: invalid argument: WHEN must be: 'always', 'auto' or 'never'" >&2
			exit 7
			;;
	esac
}

option_help() {
	if (($# > 1)); then
		echo "$0: $1: too many arguments: 1" >&2
		exit 4
	fi

	echo "$HELP"
	exit 0
}

option_version_info() {
	if (($# > 1)); then
		echo "$0: $1: too many arguments: 1" >&2
		exit 4
	fi

	echo "$VERSION_INFO"
	exit 0
}

declare ignore_opts=false argv=("$@")
for ((i = 0, s = $#; i < s; ++i)); do
	declare arg="${argv[i]}"

	if ! $ignore_opts && [[ "$arg" =~ ^--$ ]]; then
		ignore_opts=true
	elif ! $ignore_opts && [[ "$arg" =~ ^--([^=]+)(=.*)?$ ]]; then
		declare opt="${BASH_REMATCH[1]}"

		declare has_arg=false
		declare opt_arg
		if [[ "${BASH_REMATCH[2]}" =~ ^=(.*)$ ]]; then
			has_arg=true
			opt_arg="${BASH_REMATCH[1]}"
		fi

		case "$opt" in
			'silent')
				if $has_arg; then
					option_silent "--$opt" "$opt_arg"
				elif ((i + 1 < s)); then
					((++i))
					opt_arg="${argv[i]}"
					option_silent "--$opt" "$opt_arg"
				else
					option_silent "--$opt"
				fi
				;;
			'silent-all')
				if $has_arg; then
					option_silent_all "--$opt" "$opt_arg"
				else
					option_silent_all "--$opt"
				fi
				;;
			'color')
				if $has_arg; then
					option_color "--$opt" "$opt_arg"
				elif ((i + 1 < s)); then
					((++i))
					opt_arg="${argv[i]}"
					option_color "--$opt" "$opt_arg"
				else
					option_color "--$opt"
				fi
				;;
			'command')
				if $has_arg; then
					option_command "--$opt" "$opt_arg"
				elif ((i + 1 < s)); then
					((++i))
					opt_arg="${argv[i]}"
					option_command "--$opt" "$opt_arg"
				else
					option_command "--$opt"
				fi
				;;
			'command-arg')
				if $has_arg; then
					option_command_arg "--$opt" "$opt_arg"
				elif ((i + 1 < s)); then
					((++i))
					opt_arg="${argv[i]}"
					option_command_arg "--$opt" "$opt_arg"
				else
					option_command_arg "--$opt"
				fi
				;;
			'valgrind')
				if $has_arg; then
					option_valgrind "--$opt" "$opt_arg"
				else
					option_valgrind "--$opt"
				fi
				;;
			'help')
				if $has_arg; then
					option_help "--$opt" "$opt_arg"
				else
					option_help "--$opt"
				fi
				;;
			'version')
				if $has_arg; then
					option_version_info "--$opt" "$opt_arg"
				else
					option_version_info "--$opt"
				fi
				;;
			*)
				echo "$0: --$opt: invalid option" >&2
				echo "$USAGE"
				exit 5
				;;
		esac

		unset -v opt_arg has_arg opt
	elif ! $ignore_opts && [[ "$arg" =~ ^-([^-].*)$ ]]; then
		declare optstr="${BASH_REMATCH[1]}"

		for ((j = 0, l = ${#optstr}; j < l; ++j)); do
			declare opt="${optstr:0:1}"
			optstr="${optstr:1}"

			declare opt_arg

			case "$opt" in
				's')
					if [ -n "$optstr" ]; then
						j=l
						opt_arg="$optstr"
						option_silent "-$opt" "$opt_arg"
					elif ((i + 1 < s)); then
						((++i))
						opt_arg="${argv[i]}"
						option_silent "-$opt" "$opt_arg"
					else
						option_silent "-$opt"
					fi
					;;
				'c')
					if [ -n "$optstr" ]; then
						j=l
						opt_arg="$optstr"
						option_color "-$opt" "$opt_arg"
					elif ((i + 1 < s)); then
						((++i))
						opt_arg="${argv[i]}"
						option_color "-$opt" "$opt_arg"
					else
						option_color "-$opt"
					fi
					;;
				'm')
					if [ -n "$optstr" ]; then
						j=l
						opt_arg="$optstr"
						option_command "-$opt" "$opt_arg"
					elif ((i + 1 < s)); then
						((++i))
						opt_arg="${argv[i]}"
						option_command "-$opt" "$opt_arg"
					else
						option_command "-$opt"
					fi
					;;
				'A')
					if [ -n "$optstr" ]; then
						j=l
						opt_arg="$optstr"
						option_command_arg "-$opt" "$opt_arg"
					elif ((i + 1 < s)); then
						((++i))
						opt_arg="${argv[i]}"
						option_command_arg "-$opt" "$opt_arg"
					else
						option_command_arg "-$opt"
					fi
					;;
				'h'|'?')
					option_help "-$opt"
					;;
				'V'|'v')
					option_version_info "-$opt"
					;;
				*)
					echo "$0: -$opt: invalid option" >&2
					echo "$USAGE"
					exit 5
					;;
			esac

			unset -v opt_arg opt
		done

		unset -v optstr
	else
		tests+=("-$arg")
	fi

	unset -v arg
done; unset -v i s
unset -v argv ignore_opts

readonly tests color silent_all command command_args


readonly testc=$((${#tests[@]}))

if (( testc == 0 )); then
	echo "$0: missing arguments: <file>..." >&2
	echo "$USAGE"
	exit 3
fi

if $color; then
	readonly reset_clr=$'\033[0m'
	readonly failed_clr=$'\033[01;91m'
	readonly passed_clr=$'\033[01;92m'
	readonly bullet_clr=$'\033[01;94m'
	readonly strong_clr=$'\033[01;93m'
	readonly stdout_bullet_clr=$'\033[01;94m'
	readonly stderr_bullet_clr=$'\033[01;91m'
else
	readonly reset_clr='' failed_clr='' passed_clr='' bullet_clr='' strong_clr='' \
	         stdout_bullet_clr='' stderr_bullet_clr=''
fi

declare tests_maxl=-1
for ((i = 0; i < testc; ++i)); do
	declare test="${tests[i]:1}"
	((${#test} > tests_maxl)) && tests_maxl=${#test}
done
unset -v test
readonly tests_maxl

# $1: time in nanoseconds to be formatted
_format_time() {
	awk '{printf "%.2f", $1 / 10**9}' <<< "$1"
}

# $1: string to be repeated
# $2: how many times to repeat string
_repeat() {
	local string=''
	for ((i = 0; i < $2; ++i)); do
		string+="$1"
	done
	echo -n "$string"
}

# $1: number to make absolute
_abs() {
	if [ "${1:0:1}" == - ]; then
		echo -n "${1:1}"
	else
		echo -n "$1"
	fi
}

_exec_test() {
	local test="$1"

	if [ -n "$command" ]; then
		"$command" "${command_args[@]}" "$test"
	else
		./"$test"
	fi
}

# shellcheck disable=2155
declare output="Running ${strong_clr}${testc}${reset_clr} Test$( ((testc > 1)) && printf s)..."$'\n' \
        passedc=0 failedc=0 dur=0

for ((i = 0; i < testc; ++i)); do
	declare test="${tests[i]:1}" silent=false
	if [ "${tests[i]:0:1}" == s ]; then
		silent=true
	fi

	# test number and test name
	output+=' '
	declare n=$((i + 1))
	declare n_str="${bullet_clr}${n})${reset_clr}"
	for ((j = ${#n}, l = ${#testc}; j < l; ++j)) do
		n_str="$n_str "
	done
	output+="${n_str} ${test} "
	for ((j = 0, l = (tests_maxl - ${#test}) + 10; j < l; ++j)); do
		output+='.'
	done
	output+=' '

	# saving test output and adding exit status
	# shellcheck disable=2155
	declare test_output='' test_start_time=$(date +%s%N)
	test_output+=$(_exec_test "./$test" \
	               2> >(sed -E s/'^'/"$(_repeat ' ' ${#testc}) ${stderr_bullet_clr}2>${reset_clr} "/g) \
	               1> >(sed -E s/'^'/"$(_repeat ' ' ${#testc}) ${stdout_bullet_clr}1>${reset_clr} "/g))
	# shellcheck disable=2155
	declare exc=$? test_end_time=$(date +%s%N)
	if ((exc == 0)); then
		output+="${passed_clr}Passed${reset_clr}       "
		((++passedc))
	else
		output+="${failed_clr}Failed${reset_clr} (${failed_clr}${exc}${reset_clr}) "
		output+="$(_repeat ' ' "$(_abs $((${#exc} - 3)))")"
		((++failedc))
	fi
	output+="$(_format_time $((test_end_time - test_start_time)))s"
	dur=$((dur + $((test_end_time - test_start_time))))

	# adding test output
	if ! $silent_all && ! $silent && [ -n "$test_output" ]; then
		output+=$'\n'"$test_output"
	fi

	output+=$'\n'
done

# shellcheck disable=2155
declare passedp=$(awk '{printf "%.0f", $1 / $2 * 100}' <<< "$passedc $testc") \
        failedp=$(awk '{printf "%.0f", (1 - $1 / $2) * 100}' <<< "$passedc $testc")

readonly BAR_CHAR='|'

# end message
output+=$'Done\n\n'
output+="$(_repeat ' ' $((${#failedc} - ${#passedc})))$passedc/$testc ${passed_clr}Passed${reset_clr} "
output+="$(_repeat ' ' $((${#failedp} - ${#passedp})))(${passed_clr}${passedp}%${reset_clr}) "
output+="[${passed_clr}$(_repeat "$BAR_CHAR" $((passedp / 2)))${reset_clr}$(_repeat '.' $((failedp / 2)))]"
output+=$'\n'
output+="$(_repeat ' ' $((${#passedc} - ${#failedc})))$failedc/$testc ${failed_clr}Failed${reset_clr} "
output+="$(_repeat ' ' $((${#passedp} - ${#failedp})))(${failed_clr}${failedp}%${reset_clr}) "
output+="[${failed_clr}$(_repeat "$BAR_CHAR" $((failedp / 2)))${reset_clr}$(_repeat '.' $((passedp / 2)))]"
output+=$'\n'
output+="=== Time taken: $(_format_time $dur)s ==="
# yes I know this looks like hell shut up

echo "$output"

if ((passedc == testc)); then
	exit 0
elif ((passedc > 0)); then
	exit 32
else
	exit 33
fi
